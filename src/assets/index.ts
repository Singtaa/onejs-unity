/**
 * Asset loading utilities for OneJS
 *
 * Usage:
 *   import { loadImage, loadText, loadJson, loadFont } from "onejs-unity/assets"
 *
 *   // Load package assets (prefixed with @package-name/)
 *   const tex = await loadImage("@rainbow-sample/bg.png")
 *
 *   // Load user assets (from App/assets/)
 *   const logo = await loadImage("images/logo.png")
 */

declare const CS: any
declare function useExtensions(typeRef: any): void

// Register ImageConversion extension methods so tex.LoadImage(bytes) works
useExtensions(CS.UnityEngine.ImageConversion)

declare global {
    var __workingDir: string | undefined
}

// Manifest is loaded once and cached
let manifestCache: AssetManifest | null = null

interface NamespaceInfo {
    type: "user" | "package"
    package?: string
    path: string
}

interface AssetManifest {
    namespaces: Record<string, NamespaceInfo>
    userAssetsPath: string
    destPath: string
}

/**
 * Check if running in Unity Editor (not a build)
 */
function isEditor(): boolean {
    return CS.UnityEngine.Application.isEditor === true
}

/**
 * Get the working directory (where the JS app lives)
 */
function getWorkingDir(): string {
    // This should be exposed by the engine/runner
    // Falls back to dataPath parent if not available
    if (typeof globalThis.__workingDir === "string") {
        return globalThis.__workingDir
    }
    // Fallback: assume App/ is sibling to Assets/
    const dataPath = CS.UnityEngine.Application.dataPath
    const Path = CS.System.IO.Path
    return Path.Combine(Path.GetDirectoryName(dataPath), "App")
}

/**
 * Load the asset manifest (generated by copyAssetsPlugin)
 */
function loadManifest(): AssetManifest {
    if (manifestCache) return manifestCache

    const workingDir = getWorkingDir()
    const manifestPath = CS.System.IO.Path.Combine(workingDir, ".onejs", "assets-manifest.json")

    if (CS.System.IO.File.Exists(manifestPath)) {
        const content = CS.System.IO.File.ReadAllText(manifestPath)
        manifestCache = JSON.parse(content)
    } else {
        // Default manifest if none exists
        manifestCache = {
            namespaces: {},
            userAssetsPath: "assets",
            destPath: "Assets/StreamingAssets/onejs/assets",
        }
    }

    return manifestCache!
}

/**
 * Resolve an asset path to a full file path
 *
 * In Editor: resolves to working directory paths
 * In Build: resolves to StreamingAssets
 */
function resolveAssetPath(assetPath: string): string {
    const Path = CS.System.IO.Path

    if (isEditor()) {
        const workingDir = getWorkingDir()
        const manifest = loadManifest()

        // Check if path starts with @namespace/
        if (assetPath.startsWith("@")) {
            const slashIdx = assetPath.indexOf("/")
            if (slashIdx > 0) {
                const namespace = assetPath.substring(0, slashIdx)
                const relativePath = assetPath.substring(slashIdx + 1)

                const nsInfo = manifest.namespaces[namespace]
                if (nsInfo) {
                    // Resolve through manifest
                    return Path.Combine(workingDir, nsInfo.path, relativePath)
                }
            }
        }

        // User asset - resolve from assets/ folder
        return Path.Combine(workingDir, manifest.userAssetsPath, assetPath)
    } else {
        // Build mode - everything is in StreamingAssets/onejs/assets/
        const streamingAssets = CS.UnityEngine.Application.streamingAssetsPath
        return Path.Combine(streamingAssets, "onejs", "assets", assetPath)
    }
}

/**
 * Load an image from an asset path. Supports raster images (PNG, JPG) and SVG files.
 *
 * - Raster images return a Texture2D
 * - SVG files return a VectorImage (parsed and tessellated at runtime)
 *
 * @param assetPath - Relative path (e.g., "images/logo.png", "icons/star.svg")
 * @returns Texture2D or VectorImage
 */
export function loadImage(assetPath: string): any {
    const fullPath = resolveAssetPath(assetPath)

    const File = CS.System.IO.File
    if (!File.Exists(fullPath)) {
        throw new Error(`Asset not found: ${assetPath} (resolved to ${fullPath})`)
    }

    if (assetPath.toLowerCase().endsWith(".svg")) {
        return _loadSVG(fullPath)
    }

    const bytes = File.ReadAllBytes(fullPath)
    const tex = new CS.UnityEngine.Texture2D(2, 2)
    tex.LoadImage(bytes)
    tex.filterMode = CS.UnityEngine.FilterMode.Bilinear
    return tex
}

/**
 * Parse an SVG file and return a VectorImage.
 * Delegates to C# SVGUtils.LoadFromString to avoid SceneInfo struct
 * crossing the JS interop boundary (struct serialization loses complex properties).
 */
function _loadSVG(fullPath: string): any {
    const svgText = CS.System.IO.File.ReadAllText(fullPath)
    return CS.OneJS.SVGUtils.LoadFromString(svgText)
}

/**
 * Load a font from an asset path
 *
 * @param assetPath - Relative path to font file
 * @returns Font
 */
export function loadFont(assetPath: string): any {
    const fullPath = resolveAssetPath(assetPath)

    const File = CS.System.IO.File
    if (!File.Exists(fullPath)) {
        throw new Error(`Asset not found: ${assetPath} (resolved to ${fullPath})`)
    }

    return new CS.UnityEngine.Font(fullPath)
}

/**
 * Load a font definition (for UI Toolkit styling)
 *
 * @param assetPath - Relative path to font file
 * @returns FontDefinition
 */
export function loadFontDefinition(assetPath: string): any {
    const font = loadFont(assetPath)
    return CS.UnityEngine.UIElements.FontDefinition.FromFont(font)
}

/**
 * Load text from an asset path
 *
 * @param assetPath - Relative path to text file
 * @returns string content
 */
export function loadText(assetPath: string): string {
    const fullPath = resolveAssetPath(assetPath)

    const File = CS.System.IO.File
    if (!File.Exists(fullPath)) {
        throw new Error(`Asset not found: ${assetPath} (resolved to ${fullPath})`)
    }

    return File.ReadAllText(fullPath)
}

/**
 * Load JSON from an asset path
 *
 * @param assetPath - Relative path to JSON file
 * @returns parsed JSON object
 */
export function loadJson<T = any>(assetPath: string): T {
    const text = loadText(assetPath)
    return JSON.parse(text)
}

/**
 * Load raw bytes from an asset path
 *
 * @param assetPath - Relative path to file
 * @returns Uint8Array
 */
export function loadBytes(assetPath: string): Uint8Array {
    const fullPath = resolveAssetPath(assetPath)

    const File = CS.System.IO.File
    if (!File.Exists(fullPath)) {
        throw new Error(`Asset not found: ${assetPath} (resolved to ${fullPath})`)
    }

    const bytes = File.ReadAllBytes(fullPath)
    const result = new Uint8Array(bytes.Length)
    for (let i = 0; i < bytes.Length; i++) {
        result[i] = bytes[i]
    }
    return result
}

/**
 * Check if an asset exists
 *
 * @param assetPath - Relative path to check
 * @returns true if asset exists
 */
export function assetExists(assetPath: string): boolean {
    const fullPath = resolveAssetPath(assetPath)
    return CS.System.IO.File.Exists(fullPath)
}

/**
 * Get the resolved full path for an asset (for debugging or custom loading)
 *
 * @param assetPath - Relative path
 * @returns Full resolved path
 */
export function getAssetPath(assetPath: string): string {
    return resolveAssetPath(assetPath)
}

/**
 * Load a Unity resource asynchronously from the Resources folder.
 * This is a typed wrapper around the global `loadResourceAsync`.
 *
 * @param path - Resource path (relative to Resources folder, no extension)
 * @param type - Optional C# Type to load as (e.g., CS.UnityEngine.TextAsset)
 * @returns Promise resolving to the loaded asset or null
 */
export async function loadResourceAsync(path: string, type?: any): Promise<any> {
    if (type) {
        return await CS.OneJS.AssetLoader.LoadResourceAsync(path, type)
    }
    return await CS.OneJS.AssetLoader.LoadResourceAsync(path)
}
